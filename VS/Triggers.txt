-- Trigger 1: check if member loaning books exceed defined limit
-- The purpose of this trigger is to ensure that a member can borrow or reserve at most 5 books per loan or reservation. It applies the rule to both the LoanDetail and ReservationDetail tables, ensuring that the limit is enforced individually for loans and reservations.
SET SERVEROUTPUT ON;

CREATE OR REPLACE TRIGGER trg_limit_per_loan
BEFORE INSERT ON LoanDetail
FOR EACH ROW
DECLARE
    v_current_books NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_current_books
    FROM LoanDetail
    WHERE LoanID = :NEW.LoanID;
        
    IF v_current_books >= 5 THEN
        RAISE_APPLICATION_ERROR(-20000, 'Member can borrow a maximum of 5 books per loan.');
    END IF;
END;
/



-- Trigger 2: check returned book duedate and assign fine if returned late
-- The purpose of this trigger is to automatically assign a fine to a book if it is returned late. When a loan status is updated to "RETURNED," the trigger compares the return date with the book's due date. If the return date is later than the due date, the trigger generates a fine and updates the loan record to reflect the late return status. The fine is then recorded in the Fine table, and the loan detail is updated with the corresponding fine ID.
SET SERVEROUTPUT ON;

CREATE OR REPLACE TRIGGER trg_assign_fine_on_return
AFTER UPDATE OF Status ON LoanDetail
FOR EACH ROW
DECLARE
    v_due DATE;
    v_fine_id CHAR(10);
    v_fine_amount NUMBER(6,2);
BEGIN
    IF UPPER(:NEW.Status) = 'RETURNED' THEN
        v_due := COALESCE(:OLD.ExtendedDueDate, 
                         (SELECT DueDate FROM Loan WHERE LoanID = :OLD.LoanID));

        -- If returned late, calculate the fine
        IF :NEW.ReturnDate > v_due THEN
            -- Calculate the number of days overdue
            v_fine_amount := (SYSDATE - v_due) * 2;  -- RM2 per day fine

            -- Generate FineID (you can replace this with a sequence)
            v_fine_id := 'FINE' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');

            INSERT INTO Fine (FineID, FineAmount, FineStatus, IssueDate, Remark)
            VALUES (v_fine_id, v_fine_amount, 'UNPAID', SYSDATE, 'Late return');

            UPDATE LoanDetail
            SET FineID = v_fine_id,
                Status = 'LATE RETURNED'
            WHERE LoanID = :OLD.LoanID AND BookID = :OLD.BookID;
        END IF;
    END IF;
END;
/



-- trigger 
CREATE OR REPLACE TRIGGER trg_update_copies_after_loan
AFTER INSERT ON LoanDetail
FOR EACH ROW
DECLARE
	v_availableCopies 	Book.AvailableCopies%TYPE;
BEGIN
	SELECT AvailableCopies INTO v_availableCopies
	FROM Book
	WHERE BookID = :NEW.BookID;
			
	IF (v_availableCopies > 0) THEN
		UPDATE Book
		SET AvailableCopies = AvailableCopies - 1
		WHERE BookID = :NEW.BookID;
		
		:NEW.Status := 'BORROWED';
	END IF;
END;
/



-- !!!!
CREATE OR REPLACE TRIGGER trg_loan_detail_update_book
AFTER INSERT OR UPDATE OR DELETE ON LoanDetail
FOR EACH ROW
DECLARE
	v_availableCopies 	Book.AvailableCopies%TYPE;
BEGIN
    -- When a book is borrowed (INSERT)
    IF INSERTING THEN
		IF UPPER(:NEW.Status) = 'BORROWED' THEN
			UPDATE Book
			SET AvailableCopies = AvailableCopies - 1
			WHERE BookID = :NEW.BookID;
		END IF;
    -- When a book is returned (UPDATE)
    ELSIF UPDATING THEN
        IF UPPER(:OLD.Status) != 'RETURNED' AND UPPER(:NEW.Status) = 'RETURNED' THEN
            UPDATE Book
            SET AvailableCopies = AvailableCopies + 1
            WHERE BookID = :NEW.BookID;
        END IF;
    -- When a loan detail is deleted (DELETE)
    ELSIF DELETING THEN
        UPDATE Book
        SET AvailableCopies = AvailableCopies + 1
        WHERE BookID = :OLD.BookID;
    END IF;
END;
/






-- !!!!
CREATE OR REPLACE TRIGGER trg_update_membership
AFTER INSERT ON MemberRenewal
FOR EACH ROW
DECLARE
	v_newDuration 		MemberRenewal.Duration%TYPE;
	v_memberId 			Member.MemberID%TYPE;
	v_oldStartDate 		Member.StartDate%TYPE;
	v_oldEndDate 		Member.EndDate%TYPE;
BEGIN
	IF (:NEW.InvoiceID IS NOT NULL) THEN
		SELECT Duration, MemberID INTO v_newDuration, v_memberId
		FROM MemberRenewal;
		
		SELECT StartDate, EndDate INTO v_oldStartDate, v_oldEndDate
		FROM Member
		WHERE MemberID = v_memberId;
		
        IF (v_oldEndDate > SYSDATE) THEN
            UPDATE Member
            SET
                StartDate = SYSDATE,
				 EndDate = ADD_MONTHS(v_oldEndDate, v_newDuration * 12)
            WHERE MemberID = v_memberId;
        ELSE
            UPDATE Member
            SET
                StartDate = SYSDATE,
                EndDate = ADD_MONTHS(SYSDATE, v_newDuration * 12)
            WHERE MemberID = v_memberId;
        END IF;
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_availability_loan
BEFORE INSERT ON LoanDetail
FOR EACH ROW
	v_availableCopies Book.AvailableCopies%TYPE;
BEGIN
	SELECT AvailableCopies INTO v_availableCopies
	FROM Book
	WHERE BookID = :NEW.BookID;
	
	IF (v_availableCopies > 0) THEN
        UPDATE Book
        SET AvailableCopies = AvailableCopies - 1
        WHERE BookID = :NEW.BookID;
    ELSE
		RAISE_APPLICATION_ERROR(-20000, 'Book: ' || v_book_id || ' do not have enough copies!');
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_availability_res
BEFORE INSERT ON ReservationDetail
FOR EACH ROW
	v_availableCopies Book.AvailableCopies%TYPE;
BEGIN
	SELECT AvailableCopies INTO v_availableCopies
	FROM Book
	WHERE BookID = :NEW.BookID;
	
	IF (v_availableCopies > 0) THEN
        UPDATE Book
        SET AvailableCopies = AvailableCopies - 1
        WHERE BookID = :NEW.BookID;
    ELSE
		RAISE_APPLICATION_ERROR(-20000, 'Book: ' || v_book_id || ' do not have enough copies!');
    END IF;
END;
/


CREATE OR REPLACE TRIGGER trg_update_after_res
BEFORE INSERT ON ReservationDetail
FOR EACH ROW
DECLARE
    v_availableCopies Book.AvailableCopies%TYPE;
BEGIN
    SELECT AvailableCopies INTO v_availableCopies
    FROM Book
    WHERE BookID = :NEW.BookID;

    IF (v_availableCopies > 0) THEN
        -- Reduce available copies
        UPDATE Book
        SET AvailableCopies = AvailableCopies - 1
        WHERE BookID = :NEW.BookID;

        -- Mark as available
        :NEW.Status := 'AVAILABLE';
        :NEW.AvailableDate := SYSDATE;
    ELSE
        -- Mark as not available
        :NEW.Status := 'NOT AVAILABLE';
    END IF;
END;
/



CREATE OR REPLACE TRIGGER trg_set_reservation_ready
AFTER UPDATE OF Status ON ReservationDetail
FOR EACH ROW
DECLARE
    v_count_total     NUMBER;
    v_count_available NUMBER;
BEGIN
    -- Get total ReservationDetail rows for the reservation
    SELECT COUNT(*) INTO v_count_total
    FROM ReservationDetail
    WHERE ReservationID = :NEW.ReservationID;

    -- Get how many have Status = 'AVAILABLE'
    SELECT COUNT(*) INTO v_count_available
    FROM ReservationDetail
    WHERE ReservationID = :NEW.ReservationID
      AND UPPER(Status) = 'AVAILABLE';

    -- If all are available, set Reservation status to READY
    IF v_count_total = v_count_available THEN
        UPDATE Reservation
        SET ReservationStatus = 'READY'
        WHERE ReservationID = :NEW.ReservationID;
    END IF;
END;
/


CREATE OR REPLACE TRIGGER trg_update_copies_res_status
AFTER UPDATE OF ReservationStatus ON Reservation
FOR EACH ROW
DECLARE
    CURSOR cur_reserved_books IS
        SELECT BookID
        FROM ReservationDetail
        WHERE ReservationID = :NEW.ReservationID;
BEGIN 
	IF (UPPER(:NEW.ReservationStatus) IN ('COMPLETED', 'CANCELLED')) THEN
        FOR rec IN cur_reserved_books LOOP
            -- Update available copies for each book
            UPDATE Book
            SET AvailableCopies = AvailableCopies + 1
            WHERE BookID = rec.BookID;
        END LOOP;
    END IF;
END;
/

